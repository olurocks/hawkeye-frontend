// File structure for React frontend:
// 
// client/
// ├── public/
// │   ├── index.html
// │   └── favicon.ico
// ├── src/
// │   ├── components/
// │   │   ├── App.tsx
// │   │   ├── TweetCard.tsx
// │   │   └── TweetList.tsx
// │   ├── hooks/
// │   │   └── useWebSocket.ts
// │   ├── types/
// │   │   └── index.ts
// │   ├── index.tsx
// │   └── index.css
// ├── package.json
// └── tsconfig.json

// client/src/types/index.ts
export interface Tweet {
    id: string;
    text: string;
    author_id: string;
    created_at: string;
    public_metrics?: {
      retweet_count: number;
      reply_count: number;
      like_count: number;
      quote_count: number;
    };
    entities?: {
      urls?: {
        url: string;
        expanded_url: string;
        display_url: string;
      }[];
      hashtags?: {
        tag: string;
      }[];
      mentions?: {
        username: string;
      }[];
    };
  }
  
  export interface User {
    id: string;
    name: string;
    username: string;
    profile_image_url: string;
  }
  
  export interface Media {
    media_key: string;
    type: string;
    url?: string;
    preview_image_url?: string;
  }
  
  export interface TweetData {
    tweet: Tweet;
    media: Media[];
    users: User[];
  }
  
  // client/src/hooks/useWebSocket.ts
  import { useState, useEffect, useCallback, useRef } from 'react';
  import { TweetData } from '../types';
  
  type MessageHandler = (data: any) => void;
  
  export const useWebSocket = (url: string) => {
    const [isConnected, setIsConnected] = useState(false);
    const [tweets, setTweets] = useState<TweetData[]>([]);
    const [accounts, setAccounts] = useState<string[]>([]);
    const [error, setError] = useState<string | null>(null);
    const wsRef = useRef<WebSocket | null>(null);
    const reconnectAttemptsRef = useRef(0);
    const maxReconnectAttempts = 5;
  
    const connect = useCallback(() => {
      const socket = new WebSocket(url);
      wsRef.current = socket;
  
      socket.onopen = () => {
        console.log('WebSocket connected');
        setIsConnected(true);
        setError(null);
        reconnectAttemptsRef.current = 0;
        
        // Request accounts list
        socket.send(JSON.stringify({ type: 'getAccounts' }));
      };
  
      socket.onclose = () => {
        console.log('WebSocket disconnected');
        setIsConnected(false);
        
        if (reconnectAttemptsRef.current < maxReconnectAttempts) {
          const delay = Math.min(1000 * Math.pow(2, reconnectAttemptsRef.current), 30000);
          console.log(`Attempting to reconnect in ${delay / 1000} seconds...`);
          
          setTimeout(() => {
            reconnectAttemptsRef.current += 1;
            connect();
          }, delay);
        } else {
          setError('Connection lost. Unable to reconnect to the server.');
        }
      };
  
      socket.onerror = (event) => {
        console.error('WebSocket error:', event);
        setError('Error connecting to the tweet stream.');
      };
  
      socket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          if (data.type === 'accounts') {
            setAccounts(data.accounts);
          } else if (data.tweet) {
            setTweets(prevTweets => [data, ...prevTweets].slice(0, 50)); // Keep most recent 50 tweets
          }
        } catch (err) {
          console.error('Error parsing message:', err);
        }
      };
    }, [url]);
  
    const disconnect = useCallback(() => {
      if (wsRef.current) {
        wsRef.current.close();
        wsRef.current = null;
      }
    }, []);
  
    useEffect(() => {
      connect();
      return () => disconnect();
    }, [connect, disconnect]);
  
    const sendMessage = useCallback((data: any) => {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify(data));
      } else {
        console.error('WebSocket is not connected');
      }
    }, []);
  
    return { isConnected, tweets, accounts, error, sendMessage };
  };
  
  // client/src/components/TweetCard.tsx
  import React from 'react';
  import { Tweet, User, Media } from '../types';
  
  interface TweetCardProps {
    tweet: Tweet;
    user: User;
    media: Media[];
  }
  
  const TweetCard: React.FC<TweetCardProps> = ({ tweet, user, media }) => {
    const formatDate = (dateString: string) => {
      const date = new Date(dateString);
      return date.toLocaleString();
    };
  
    const formatTweetText = (text: string, entities?: Tweet['entities']) => {
      if (!entities) return text;
      
      let formattedText = text;
      
      // Format URLs
      if (entities.urls) {
        entities.urls.forEach(urlEntity => {
          formattedText = formattedText.replace(
            urlEntity.url,
            `<a href="${urlEntity.expanded_url}" target="_blank" rel="noopener noreferrer" class="text-blue-500 hover:underline">${urlEntity.display_url}</a>`
          );
        });
      }
      
      // Format hashtags
      if (entities.hashtags) {
        entities.hashtags.forEach(hashtag => {
          const hashtagText = `#${hashtag.tag}`;
          formattedText = formattedText.replace(
            new RegExp(hashtagText, 'gi'),
            `<a href="https://twitter.com/hashtag/${hashtag.tag}" target="_blank" rel="noopener noreferrer" class="text-blue-500 hover:underline">${hashtagText}</a>`
          );
        });
      }
      
      // Format mentions
      if (entities.mentions) {
        entities.mentions.forEach(mention => {
          const mentionText = `@${mention.username}`;
          formattedText = formattedText.replace(
            new RegExp(mentionText, 'gi'),
            `<a href="https://twitter.com/${mention.username}" target="_blank" rel="noopener noreferrer" class="text-blue-500 hover:underline">${mentionText}</a>`
          );
        });
      }
      
      return formattedText;
    };
  
    return (
      <div className="bg-white rounded-lg shadow p-4 mb-4 transition-all duration-300 hover:shadow-lg">
        <div className="flex items-start">
          <img 
            src={user.profile_image_url} 
            alt={user.name} 
            className="w-12 h-12 rounded-full mr-4"
          />
          <div className="flex-1">
            <div className="flex items-center">
              <h3 className="font-bold text-gray-900">{user.name}</h3>
              <span className="text-gray-500 ml-2">@{user.username}</span>
            </div>
            
            <div 
              className="my-2"
              dangerouslySetInnerHTML={{ __html: formatTweetText(tweet.text, tweet.entities) }}
            />
            
            {media && media.length > 0 && (
              <div className="mt-2 rounded overflow-hidden">
                {media.map(item => (
                  item.type === 'photo' && item.url ? (
                    <img 
                      key={item.media_key}
                      src={item.url} 
                      alt="Tweet media" 
                      className="w-full rounded"
                    />
                  ) : item.type === 'video' && item.preview_image_url ? (
                    <img 
                      key={item.media_key}
                      src={item.preview_image_url} 
                      alt="Video thumbnail" 
                      className="w-full rounded"
                    />
                  ) : null
                ))}
              </div>
            )}
            
            <div className="flex items-center text-gray-500 text-sm mt-2">
              <span>{formatDate(tweet.created_at)}</span>
              {tweet.public_metrics && (
                <>
                  <span className="mx-2">•</span>
                  <span>{tweet.public_metrics.like_count || 0} Likes</span>
                  <span className="mx-2">•</span>
                  <span>{tweet.public_metrics.retweet_count || 0} Retweets</span>
                </>
              )}
            </div>
          </div>
        </div>
      </div>
    );
  };
  
  export default TweetCard;
  
  // client/src/components/TweetList.tsx
  import React from 'react';
  import TweetCard from './TweetCard';
  import { TweetData } from '../types';
  
  interface TweetListProps {
    tweets: TweetData[];
    isConnected: boolean;
    error: string | null;
  }
  
  const TweetList: React.FC<TweetListProps> = ({ tweets, isConnected, error }) => {
    if (error) {
      return (
        <div className="text-center text-red-500 p-6 bg-red-50 rounded-lg">
          <p>{error}</p>
          <button 
            onClick={() => window.location.reload()}
            className="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            Refresh
          </button>
        </div>
      );
    }
  
    if (!isConnected) {
      return (
        <div className="text-center p-6 bg-blue-50 rounded-lg animate-pulse">
          <p className="text-blue-500">Connecting to tweet stream...</p>
        </div>
      );
    }
  
    if (tweets.length === 0) {
      return (
        <div className="text-center text-gray-500 p-6 bg-gray-50 rounded-lg">
          <p>Waiting for tweets...</p>
        </div>
      );
    }
  
    return (
      <div className="space-y-4">
        {tweets.map(({ tweet, users, media }) => {
          const user = users.find(u => u.id === tweet.author_id);
          if (!user) return null;
          
          return (
            <TweetCard
              key={tweet.id}
              tweet={tweet}
              user={user}
              media={media}
            />
          );
        })}
      </div>
    );
  };
  
  export default TweetList;
  
  // client/src/components/App.tsx
  import React from 'react';
  import TweetList from './TweetList';
  import { useWebSocket } from '../hooks/useWebSocket';
  
  const App: React.FC = () => {
    // Get WebSocket URL from the same host with proper protocol
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}`;
    
    const { isConnected, tweets, accounts, error } = useWebSocket(wsUrl);
  
    return (
      <div className="min-h-screen bg-gray-100">
        <div className="container mx-auto px-4 py-8">
          <header className="mb-8 text-center">
            <h1 className="text-3xl font-bold text-blue-600">Real-time Twitter Feed</h1>
            {accounts.length > 0 && (
              <p className="text-gray-600 mt-2">
                Following: <span className="font-semibold">{accounts.join(', ')}</span>
              </p>
            )}
            <div className="mt-2">
              <span className={`inline-block w-3 h-3 rounded-full mr-2 ${isConnected ? 'bg-green-500' : 'bg-red-500'}`}></span>
              <span className="text-sm text-gray-600">
                {isConnected ? 'Connected' : 'Disconnected'}
              </span>
            </div>
          </header>
          
          <TweetList 
            tweets={tweets}
            isConnected={isConnected}
            error={error}
          />
        </div>
      </div>
    );
  };
  
  export default App;
  
  // client/src/index.tsx
  import React from 'react';
  import ReactDOM from 'react-dom/client';
  import './index.css';
  import App from './components/App';
  
  const root = ReactDOM.createRoot(
    document.getElementById('root') as HTMLElement
  );
  
  root.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
  
  // client/src/index.css
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
  
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
  
  body {
    margin: 0;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
      'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
      sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  
  .animate-pulse {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }
  
  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: .5;
    }
  }
  
  // client/package.json
  {
    "name": "twitter-stream-client",
    "version": "0.1.0",
    "private": true,
    "proxy": "http://localhost:3000",
    "dependencies": {
      "react": "^18.2.0",
      "react-dom": "^18.2.0",
      "react-scripts": "5.0.1",
      "typescript": "^4.9.5",
      "web-vitals": "^2.1.4"
    },
    "devDependencies": {
      "@types/node": "^16.18.46",
      "@types/react": "^18.2.21",
      "@types/react-dom": "^18.2.7",
      "autoprefixer": "^10.4.15",
      "postcss": "^8.4.29",
      "tailwindcss": "^3.3.3"
    },
    "scripts": {
      "start": "react-scripts start",
      "build": "react-scripts build",
      "test": "react-scripts test",
      "eject": "react-scripts eject"
    },
    "eslintConfig": {
      "extends": [
        "react-app",
        "react-app/jest"
      ]
    },
    "browserslist": {
      "production": [
        ">0.2%",
        "not dead",
        "not op_mini all"
      ],
      "development": [
        "last 1 chrome version",
        "last 1 firefox version",
        "last 1 safari version"
      ]
    }
  }
  
  // client/public/index.html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8" />
      <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <meta name="theme-color" content="#000000" />
      <meta
        name="description"
        content="Real-time Twitter feed application"
      />
      <title>Twitter Feed</title>
    </head>
    <body>
      <noscript>You need to enable JavaScript to run this app.</noscript>
      <div id="root"></div>
    </body>
  </html>
  
  // client/tsconfig.json
  {
    "compilerOptions": {
      "target": "es5",
      "lib": [
        "dom",
        "dom.iterable",
        "esnext"
      ],
      "allowJs": true,
      "skipLibCheck": true,
      "esModuleInterop": true,
      "allowSyntheticDefaultImports": true,
      "strict": true,
      "forceConsistentCasingInFileNames": true,
      "noFallthroughCasesInSwitch": true,
      "module": "esnext",
      "moduleResolution": "node",
      "resolveJsonModule": true,
      "isolatedModules": true,
      "noEmit": true,
      "jsx": "react-jsx"
    },
    "include": [
      "src"
    ]
  }
  
  // client/tailwind.config.js
  module.exports = {
    content: [
      "./src/**/*.{js,jsx,ts,tsx}",
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }
  
  // client/postcss.config.js
  module.exports = {
    plugins: {
      tailwindcss: {},
      autoprefixer: {},
    },
  }